<!DOCTYPE html>
<head>
    <!-- 頁面標題 -->
    <title>Process RAW PCM data using RecordRTC</title>
    <!-- 字符編碼設定 -->
    <meta charset="utf-8">
    <!-- 引入自定義樣式表 -->
    <link rel="stylesheet" href="assets/css/style.css">
    <!-- 引入 WaveSurfer.js 波形顯示庫 (版本 7) -->
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
</head>

<body>
<!-- 主標題：說明使用 RecordRTC 處理 PCM 數據 -->
<h1>Process RAW PCM data using RecordRTC</h1>
<!-- 示例文字：用於測試錄音的中文語句 -->
<h2>請念：以二號女友為例，她堅持不下廚，你要娶一個巧婦，就形成對立局面。</h2>
<!-- 顯示錄音時長的區域 -->
<h3>length</h3>
<!-- 預留的標題區域 -->
<h4>what?</h4>

<!-- 分隔線 -->
<br>
<!-- 錄音控制按鈕區域 -->
<button id="btn-start-recording">開始錄音</button>
<button id="btn-stop-recording" disabled>結束錄音</button>

<br>

<!-- WaveSurfer 波形顯示容器
     - 寬度: 750px, 高度: 200px
     - 邊框: 1px 灰色實線
     - 上下間距: 20px -->
<div id="waveform" style="width: 750px; height: 200px; border: 1px solid #ccc; margin: 20px 0;"></div>

<br>

<!-- HTML5 音頻播放控制器
     - controls: 顯示播放控制界面
     - playsinline: 在移動設備上內聯播放 -->
<audio controls playsinline></audio>

<!-- 分隔線 -->
<hr>

<!-- 錄音片段容器：用於顯示所有錄音片段及其波形 -->
<div id="audio-blobs-container" style="margin-top: 20px;">
    <h2 style="margin-bottom: 20px;">Audio Blobs Goes Here:</h2>
</div>

<!-- 引入 RecordRTC 錄音庫 -->
<script src="assets/js/RecordRTC.js"></script>

<script>
    /*=================================================================
     * 全域變數宣告區域
     * 定義應用程式中需要的主要變數和狀態
     *================================================================*/
    
    // DOM 元素引用
    var audio = document.querySelector('audio');                    // 主要音頻播放元素
    var audioBlobsContainer = document.querySelector('#audio-blobs-container'); // 錄音片段容器
    
    // 錄音狀態控制變數
    var is_ready_to_record = true;   // 是否準備好錄音
    var is_recording = false;        // 是否正在錄音
    var is_recorded = false;         // 是否已完成錄音

    // Web Audio API 相關物件
    var audioContext = new (window.AudioContext || window.webkitAudioContext)(); // 音頻上下文
    var analyser = audioContext.createAnalyser();                                // 音頻分析器
    var dataArray = new Uint8Array(analyser.frequencyBinCount);                 // 頻域數據陣列

    /*=================================================================
     * WaveSurfer.js 初始化
     * 設定主要的波形顯示組件
     *================================================================*/
    
    // 初始化主要的 WaveSurfer 實例
    var wavesurfer = WaveSurfer.create({
        container: '#waveform',        // 容器選擇器
        waveColor: '#4CAF50',          // 波形顏色（綠色）
        progressColor: '#2196F3',      // 播放進度顏色（藍色）
        cursorColor: '#FF5722',        // 游標顏色（橙紅色）
        barWidth: 2,                   // 波形條寬度
        barRadius: 3,                  // 波形條圓角
        responsive: true,              // 響應式設計
        height: 200,                   // 波形高度
        normalize: true,               // 標準化波形振幅
        backend: 'WebAudio',           // 使用 Web Audio API 後端
        mediaControls: false           // 不顯示媒體控制按鈕
    });

    /*=================================================================
     * WaveSurfer 事件監聽器
     * 處理波形組件的各種事件
     *================================================================*/
    
    // WaveSurfer 準備完成事件
    wavesurfer.on('ready', function() {
        console.log('WaveSurfer is ready'); // 波形組件準備完成
    });

    // WaveSurfer 錯誤處理事件
    wavesurfer.on('error', function(e) {
        console.error('WaveSurfer error:', e); // 記錄波形組件錯誤
    });

    /*=================================================================
     * 輔助工具函數
     * 提供時間計算、麥克風捕獲等通用功能
     *================================================================*/

    /**
     * 將秒數轉換為時:分:秒格式
     * @param {number} secs - 總秒數
     * @returns {string} 格式化的時間字串 (HH:MM:SS 或 MM:SS)
     */
    function calculateTimeDuration(secs) {
        var hr = Math.floor(secs / 3600);           // 計算小時
        var min = Math.floor((secs - (hr * 3600)) / 60); // 計算分鐘
        var sec = Math.floor(secs - (hr * 3600) - (min * 60)); // 計算秒數

        // 格式化分鐘：小於10時前面補0
        if (min < 10) {
            min = "0" + min;
        }

        // 格式化秒數：小於10時前面補0
        if (sec < 10) {
            sec = "0" + sec;
        }

        // 如果沒有小時，只顯示分:秒
        if(hr <= 0) {
            return min + ':' + sec;
        }

        // 有小時時顯示時:分:秒
        return hr + ':' + min + ':' + sec;
    }

    /**
     * 捕獲用戶麥克風
     * 請求麥克風權限並獲取音頻流
     * @param {function} callback - 成功獲取麥克風後的回調函數
     */
    function captureMicrophone(callback) {
        navigator.mediaDevices.getUserMedia({
            audio: {
                echoCancellation: false,    // 關閉回音消除
                noiseSuppression: false,    // 關閉噪音抑制
                autoGainControl: false      // 關閉自動增益控制
            },
            video: false                    // 不需要視頻
        }).then(function(microphone) {
            callback(microphone);           // 成功時執行回調
        }).catch(function(error) {
            // 錯誤處理：顯示錯誤訊息並記錄到控制台
            alert('Unable to capture your microphone. Please check console logs.');
            console.error(error);
        });
    }

    /*=================================================================
     * 停止錄音回調函數
     * 處理錄音停止後的各種操作：波形生成、檔案上傳等
     *================================================================*/
    
    /**
     * 錄音停止後的回調函數
     * 處理錄音數據、生成波形、上傳檔案等操作
     */
    function stopRecordingCallback() {
        /*---------------------------------------------------------------
         * 獲取錄音器內部數據
         * 從 RecordRTC 獲取左右聲道的原始音頻數據
         *--------------------------------------------------------------*/
        
        // 獲取 StereoAudioRecorder 物件（內部錄音器）
        var internalRecorder = recorder.getInternalRecorder();
        
        // 獲取左右聲道數據
        var leftchannel = internalRecorder.leftchannel;   // 左聲道數據
        var rightchannel = internalRecorder.rightchannel; // 右聲道數據

        /*---------------------------------------------------------------
         * 生成自定義 WAV 檔案
         * 使用原始 PCM 數據手動創建 WAV 格式音頻
         *--------------------------------------------------------------*/
        
        // 調用音頻緩衝區合併函數，生成最終的 WAV 檔案
        mergeLeftRightBuffers({
            desiredSampRate: internalRecorder.desiredSampRate,           // 目標採樣率
            sampleRate: internalRecorder.sampleRate,                     // 原始採樣率
            numberOfAudioChannels: internalRecorder.numberOfAudioChannels, // 聲道數量
            internalInterleavedLength: internalRecorder.recordingLength,  // 錄音長度
            leftBuffers: leftchannel,                                     // 左聲道緩衝區
            rightBuffers: internalRecorder.numberOfAudioChannels === 1 ? [] : rightchannel // 右聲道緩衝區（單聲道時為空陣列）
        }, function(buffer, view) {
            /*-----------------------------------------------------------
             * WAV 檔案生成完成回調
             * 將生成的音頻數據載入到播放器和波形顯示器
             *----------------------------------------------------------*/
            
            // 創建 Blob 物件（WAV 格式）
            var blob = new Blob([buffer], {
                type: 'audio/wav'
            });
            
            // 將音頻載入到主播放器
            audio.srcObject = null;
            audio.src = URL.createObjectURL(blob);
            
            // 將最終錄音載入到主要的 WaveSurfer 顯示器
            wavesurfer.load(URL.createObjectURL(blob));
            
            /*-----------------------------------------------------------
             * 同步主音頻播放器與 WaveSurfer
             * 實現點擊波形控制播放功能
             *----------------------------------------------------------*/
            wavesurfer.on('click', function() {
                // 設定音頻播放位置為波形點擊位置
                audio.currentTime = wavesurfer.getCurrentTime();
                
                // 根據 WaveSurfer 播放狀態控制音頻播放
                if (wavesurfer.isPlaying()) {
                    audio.play();   // 開始播放
                } else {
                    audio.pause();  // 暫停播放
                }
            });
        });

        /*---------------------------------------------------------------
         * 停止麥克風並上傳檔案
         * 清理資源並開始檔案上傳流程
         *--------------------------------------------------------------*/
        
        recorder.microphone.stop(); // 停止麥克風錄音
        var button = this;           // 保存按鈕引用
        
        // 上傳錄音檔案到伺服器
        uploadToServer(recorder, function(progress, fileURL) {
            if(progress === 'ended') {
                // 上傳完成：更新按鈕狀態為下載連結
                button.disabled = false;
                button.innerHTML = 'Click to download from server';
                button.onclick = function() {
                    window.open(fileURL); // 開啟下載連結
                };
                return;
            }
            // 上傳進行中：更新按鈕文字顯示進度
            button.innerHTML = progress;
        });

        /*---------------------------------------------------------------
         * 檔案上傳相關函數
         * 處理檔案上傳到 PHP 後端的邏輯
         *--------------------------------------------------------------*/
        
        var listOfFilesUploaded = []; // 已上傳檔案清單

        /**
         * 上傳錄音檔案到伺服器
         * @param {Object} recordRTC - RecordRTC 錄音器實例或 Blob 物件
         * @param {function} callback - 進度回調函數
         */
        function uploadToServer(recordRTC, callback) {
            // 獲取 Blob 物件（可能直接是 Blob 或從 RecordRTC 提取）
            var blob = recordRTC instanceof Blob ? recordRTC : recordRTC.blob;
            var fileType = blob.type.split('/')[0] || 'audio'; // 獲取檔案類型（通常是 'audio'）
            
            // 生成唯一檔案名稱
            var fileName = 'xxx_' + (Math.random() * 1000).toString().replace('.', '');
            
            // 根據瀏覽器類型設定檔案副檔名
            if (fileType === 'audio') {
                fileName += '.' + (!!navigator.mozGetUserMedia ? 'ogg' : 'wav'); // Firefox 使用 ogg，其他使用 wav
            } else {
                fileName += '.webm'; // 視頻檔案使用 webm
            }

            // 創建 FormData 物件用於檔案上傳
            var formData = new FormData();
            formData.append(fileType + '-filename', fileName); // 檔案名稱
            formData.append(fileType + '-blob', blob);          // 檔案內容

            callback('Uploading ' + fileType + ' recording to server.'); // 通知開始上傳

            // 伺服器端點設定
            var upload_url = 'save.php';        // 上傳處理 PHP 檔案
            var upload_directory = 'uploads/';   // 上傳目錄

            // 執行 HTTP 請求上傳檔案
            makeXMLHttpRequest(upload_url, formData, function(progress) {
                if (progress !== 'upload-ended') {
                    callback(progress); // 更新上傳進度
                    return;
                }

                callback('ended', upload_directory + fileName); // 上傳完成

                // 將檔案加入已上傳清單（用於離開頁面時清理）
                listOfFilesUploaded.push(upload_directory + fileName);
            });
        }

        /**
         * 建立 XMLHttpRequest 請求上傳檔案
         * @param {string} url - 上傳目標 URL
         * @param {FormData} data - 要上傳的表單數據
         * @param {function} callback - 進度回調函數
         */
        function makeXMLHttpRequest(url, data, callback) {
            var request = new XMLHttpRequest(); // 創建 HTTP 請求物件
            
            // 請求狀態變化處理
            request.onreadystatechange = function() {
                if (request.readyState == 4 && request.status == 200) {
                    callback('upload-ended'); // 上傳完成
                }
            };

            // 上傳開始事件
            request.upload.onloadstart = function() {
                callback('Upload started...');
            };

            // 上傳進度事件
            request.upload.onprogress = function(event) {
                callback('Upload Progress ' + Math.round(event.loaded / event.total * 100) + "%");
            };

            // 上傳即將結束事件
            request.upload.onload = function() {
                callback('progress-about-to-end');
            };

            // 上傳完成事件
            request.upload.onload = function() {
                callback('progress-ended');
            };

            // 上傳錯誤處理
            request.upload.onerror = function(error) {
                callback('Failed to upload to server');
                console.error('XMLHttpRequest failed', error);
            };

            // 上傳中止處理
            request.upload.onabort = function(error) {
                callback('Upload aborted.');
                console.error('XMLHttpRequest aborted', error);
            };

            // 發送 POST 請求
            request.open('POST', url);
            request.send(data);
        }
        
        recorder = null; // 清空錄音器引用
    }

    /*=================================================================
     * 全域錄音器變數
     * 用於在不同函數間共享錄音器實例
     *================================================================*/
    var recorder; // 全域可訪問的錄音器物件

    /*=================================================================
     * 開始錄音按鈕事件處理
     * 處理使用者點擊開始錄音時的所有邏輯
     *================================================================*/
    
    document.getElementById('btn-start-recording').onclick = function() {
        /*---------------------------------------------------------------
         * 初始化錄音狀態
         * 設定各種狀態變數並清理之前的錄音
         *--------------------------------------------------------------*/
        this.disabled = true;           // 禁用開始錄音按鈕
        is_ready_to_record = false;     // 設定為非準備狀態
        is_recording = true;            // 設定為錄音中
        is_recorded = false;            // 設定為未完成錄音

        // 清空之前的錄音片段容器
        let element = audioBlobsContainer;
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
        
        // 清空主要波形顯示
        wavesurfer.empty();

        /*---------------------------------------------------------------
         * 捕獲麥克風並開始錄音
         * 獲取用戶麥克風權限並初始化 RecordRTC
         *--------------------------------------------------------------*/
        captureMicrophone(function(microphone) {
            // 將麥克風音頻流設定到主音頻元素
            audio.srcObject = microphone;

            /*-----------------------------------------------------------
             * 初始化 RecordRTC 錄音器
             * 設定錄音參數和即時處理回調
             *----------------------------------------------------------*/
            recorder = RecordRTC(microphone, {
                type: 'audio',                    // 錄音類型：音頻
                mimeType: 'audio/wav',            // 輸出格式：WAV
                recorderType: StereoAudioRecorder, // 使用立體聲錄音器
                numberOfAudioChannels: 1,         // 聲道數：單聲道
                // sampleRate: 48000,             // 採樣率（註解掉使用預設值）
                // desiredSampRate: 48000,        // 目標採樣率（註解掉使用預設值）
                bufferSize: 16384,                // 緩衝區大小
                timeSlice: 1000,                  // 時間片段：每1000ms觸發一次 ondataavailable
                
                /*-------------------------------------------------------
                 * 即時音頻數據處理回調
                 * 每1000ms會觸發一次，接收錄音片段
                 *------------------------------------------------------*/
                ondataavailable: function(blob) {
                    /*---------------------------------------------------
                     * 音頻 Blob 轉 AudioBuffer 處理函數
                     * 將音頻 Blob 轉換為 AudioBuffer 以進行波形分析
                     *--------------------------------------------------*/
                    function convertBlobToAudioBuffer(myBlob) {
                        const audioContext = new AudioContext();  // 創建音頻上下文
                        const fileReader = new FileReader();      // 創建檔案讀取器

                        // 檔案讀取完成事件
                        fileReader.onloadend = () => {
                            let myArrayBuffer = fileReader.result; // 獲取 ArrayBuffer

                            // 解碼音頻數據為 AudioBuffer
                            audioContext.decodeAudioData(myArrayBuffer, (audioBuffer) => {
                                console.log(audioBuffer); // 記錄 AudioBuffer 資訊
                                
                                // 創建臨時音頻 URL 供 WaveSurfer 使用
                                const blobUrl = URL.createObjectURL(myBlob);
                                
                                // 將音頻載入到 WaveSurfer 波形顯示器
                                wavesurfer.load(blobUrl);
                                
                                // 波形準備完成後清理臨時 URL
                                wavesurfer.on('ready', () => {
                                    URL.revokeObjectURL(blobUrl);
                                });
                            });
                        };
                        
                        // 將 Blob 讀取為 ArrayBuffer
                        fileReader.readAsArrayBuffer(myBlob);
                    }
                    
                    // 處理當前音頻片段
                    convertBlobToAudioBuffer(blob);

                    /*---------------------------------------------------
                     * 創建錄音片段顯示容器
                     * 為每個錄音片段創建獨立的顯示區域和波形
                     *--------------------------------------------------*/
                    
                    // 創建音頻片段的主容器
                    var audioContainer = document.createElement('div');
                    audioContainer.style.cssText = 'margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; background-color: #f9f9f9;';
                    
                    // 為此波形創建唯一 ID
                    var waveformId = 'waveform-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                    var waveformDiv = document.createElement('div');
                    waveformDiv.id = waveformId;
                    waveformDiv.style.cssText = 'width: 100%; height: 60px; margin: 10px 0;';
                    
                    // 創建音頻播放控制器
                    var au = document.createElement('audio');
                    au.controls = true;                        // 顯示播放控制
                    au.srcObject = null;                       // 清空媒體流
                    au.src = URL.createObjectURL(blob);        // 設定音頻來源
                    
                    // 組織容器結構
                    audioContainer.appendChild(waveformDiv);   // 添加波形容器
                    audioContainer.appendChild(au);            // 添加音頻控制器
                    audioBlobsContainer.appendChild(audioContainer); // 添加到主容器
                    audioBlobsContainer.appendChild(document.createElement('hr')); // 添加分隔線
                    
                    /*---------------------------------------------------
                     * 為此音頻片段創建專屬的 WaveSurfer 實例
                     * 每個錄音片段都有自己的波形顯示器
                     *--------------------------------------------------*/
                    var blobWavesurfer = WaveSurfer.create({
                        container: '#' + waveformId,  // 容器選擇器
                        waveColor: '#8BC34A',         // 波形顏色（淺綠色）
                        progressColor: '#4CAF50',     // 進度顏色（綠色）
                        cursorColor: '#FF9800',       // 游標顏色（橙色）
                        barWidth: 1,                  // 波形條寬度
                        barRadius: 2,                 // 波形條圓角
                        responsive: true,             // 響應式設計
                        height: 60,                   // 波形高度（較小）
                        normalize: true,              // 標準化振幅
                        backend: 'WebAudio',          // 使用 Web Audio API
                        mediaControls: false          // 不顯示媒體控制
                    });
                    
                    // 將音頻 Blob 載入到波形顯示器
                    blobWavesurfer.load(au.src);
                    
                    /*---------------------------------------------------
                     * 同步波形與音頻播放器
                     * 實現波形與 HTML5 audio 元素的雙向同步
                     *--------------------------------------------------*/
                    
                    // 點擊波形時的處理
                    blobWavesurfer.on('click', function() {
                        blobWavesurfer.playPause();               // 切換波形播放狀態
                        if (blobWavesurfer.isPlaying()) {
                            au.currentTime = blobWavesurfer.getCurrentTime(); // 同步播放位置
                            au.play();                            // 播放音頻
                        } else {
                            au.pause();                           // 暫停音頻
                        }
                    });
                    
                    // 音頻開始播放時同步波形
                    au.addEventListener('play', function() {
                        blobWavesurfer.play();
                    });
                    
                    // 音頻暫停時同步波形
                    au.addEventListener('pause', function() {
                        blobWavesurfer.pause();
                    });
                    
                    // 音頻時間更新時同步波形位置
                    au.addEventListener('timeupdate', function() {
                        if (!blobWavesurfer.isPlaying()) {
                            blobWavesurfer.seekTo(au.currentTime / au.duration);
                        }
                    });
                }
            });

            /*-----------------------------------------------------------
             * 開始錄音並設定時間顯示
             * 啟動錄音器並開始計時顯示
             *----------------------------------------------------------*/
            recorder.startRecording(); // 開始錄音

            dateStarted = new Date().getTime(); // 記錄開始時間

            /*-----------------------------------------------------------
             * 錄音時間顯示循環
             * 每秒更新一次錄音時長顯示
             *----------------------------------------------------------*/
            (function looper() {
                if(!recorder) {
                    return; // 如果錄音器不存在則停止循環
                }

                // 更新時長顯示：計算並顯示已錄音時間
                document.querySelector('h3').innerHTML = 'Recording Duration: ' + 
                    calculateTimeDuration((new Date().getTime() - dateStarted) / 1000);

                setTimeout(looper, 1000); // 1秒後再次執行
            })();

            /*-----------------------------------------------------------
             * 保存麥克風引用並啟用停止按鈕
             * 為停止錄音時釋放麥克風做準備
             *----------------------------------------------------------*/
            recorder.microphone = microphone; // 保存麥克風引用
            document.getElementById('btn-stop-recording').disabled = false; // 啟用停止錄音按鈕
        });
    };

    /*=================================================================
     * 停止錄音按鈕事件處理
     * 處理使用者點擊停止錄音時的所有邏輯
     *================================================================*/
    
    document.getElementById('btn-stop-recording').onclick = function() {
        /*---------------------------------------------------------------
         * 更新錄音狀態
         * 設定各種狀態變數並觸發停止錄音流程
         *--------------------------------------------------------------*/
        this.disabled = true;                    // 禁用停止錄音按鈕
        recorder.stopRecording(stopRecordingCallback); // 停止錄音並執行回調
        
        // 更新狀態變數
        is_ready_to_record = true;               // 設定為準備錄音狀態
        is_recording = false;                    // 設定為非錄音中
        is_recorded = true;                      // 設定為已完成錄音
        
        document.getElementById('btn-start-recording').disabled = false; // 重新啟用開始錄音按鈕
    };

    /*=================================================================
     * 音頻處理工具函數
     * 以下函數處理原始 PCM 數據並生成 WAV 檔案
     * (改編自 StereoAudioRecorder.js，用於說明如何處理原始 PCM 數據)
     *================================================================*/

    /**
     * 合併左右聲道緩衝區
     * 將分離的左右聲道數據合併為完整的音頻檔案
     * @param {Object} config - 音頻配置物件
     * @param {function} callback - 完成回調函數
     */
    function mergeLeftRightBuffers(config, callback) {
        /**
         * 音頻緩衝區合併主函數
         * 處理聲道合併、採樣率轉換、WAV 格式生成
         * @param {Object} config - 音頻配置參數
         * @param {function} cb - 回調函數
         */
        function mergeAudioBuffers(config, cb) {
            var numberOfAudioChannels = config.numberOfAudioChannels; // 聲道數量

            /*-----------------------------------------------------------
             * 複製音頻緩衝區數據
             * 使用 slice(0) 創建數據副本以避免修改原始數據
             *----------------------------------------------------------*/
            var leftBuffers = config.leftBuffers.slice(0);   // 左聲道緩衝區副本
            var rightBuffers = config.rightBuffers.slice(0); // 右聲道緩衝區副本
            var sampleRate = config.sampleRate;              // 原始採樣率
            var internalInterleavedLength = config.internalInterleavedLength; // 交錯數據長度
            var desiredSampRate = config.desiredSampRate;    // 目標採樣率

            /*-----------------------------------------------------------
             * 處理立體聲音頻 (雙聲道)
             * 合併緩衝區並進行採樣率轉換
             *----------------------------------------------------------*/
            if (numberOfAudioChannels === 2) {
                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);   // 合併左聲道
                rightBuffers = mergeBuffers(rightBuffers, internalInterleavedLength); // 合併右聲道
                
                // 如果需要改變採樣率，進行插值處理
                if (desiredSampRate) {
                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);
                    rightBuffers = interpolateArray(rightBuffers, desiredSampRate, sampleRate);
                }
            }

            /*-----------------------------------------------------------
             * 處理單聲道音頻
             * 只需處理左聲道數據
             *----------------------------------------------------------*/
            if (numberOfAudioChannels === 1) {
                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength); // 合併左聲道
                
                // 如果需要改變採樣率，進行插值處理
                if (desiredSampRate) {
                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);
                }
            }

            /*-----------------------------------------------------------
             * 更新採樣率
             * 如果指定了目標採樣率，更新當前採樣率變數
             *----------------------------------------------------------*/
            if (desiredSampRate) {
                sampleRate = desiredSampRate; // 設定為目標採樣率
            }

            /*-----------------------------------------------------------
             * 採樣率轉換相關函數
             * 參考資料: http://stackoverflow.com/a/28977136/552182
             *----------------------------------------------------------*/
            
            /**
             * 陣列插值函數 - 用於採樣率轉換
             * 使用線性插值將音頻數據從一個採樣率轉換到另一個採樣率
             * @param {Array} data - 原始音頻數據陣列
             * @param {number} newSampleRate - 目標採樣率
             * @param {number} oldSampleRate - 原始採樣率
             * @returns {Array} 轉換後的音頻數據陣列
             */
            function interpolateArray(data, newSampleRate, oldSampleRate) {
                var fitCount = Math.round(data.length * (newSampleRate / oldSampleRate)); // 計算新陣列長度
                var newData = [];                                                          // 新數據陣列
                var springFactor = Number((data.length - 1) / (fitCount - 1));        // 插值彈性係數
                
                newData[0] = data[0]; // 設定第一個數據點（邊界條件）
                
                // 對中間的數據點進行線性插值
                for (var i = 1; i < fitCount - 1; i++) {
                    var tmp = i * springFactor;                                        // 計算插值位置
                    var before = Number(Math.floor(tmp)).toFixed();                    // 前一個數據點索引
                    var after = Number(Math.ceil(tmp)).toFixed();                      // 後一個數據點索引
                    var atPoint = tmp - before;                                        // 插值權重
                    newData[i] = linearInterpolate(data[before], data[after], atPoint); // 線性插值計算
                }
                
                newData[fitCount - 1] = data[data.length - 1]; // 設定最後一個數據點（邊界條件）
                return newData; // 返回插值後的數據
            }

            /**
             * 線性插值函數
             * 在兩個數據點之間進行線性插值
             * @param {number} before - 前一個數據點的值
             * @param {number} after - 後一個數據點的值
             * @param {number} atPoint - 插值位置 (0-1 之間)
             * @returns {number} 插值結果
             */
            function linearInterpolate(before, after, atPoint) {
                return before + (after - before) * atPoint; // 線性插值計算公式
            }

            /**
             * 合併多個音頻緩衝區
             * 將多個小的音頻緩衝區合併為一個連續的大緩衝區
             * @param {Array} channelBuffer - 音頻緩衝區陣列
             * @param {number} rLength - 結果陣列的總長度
             * @returns {Float64Array} 合併後的音頻數據
             */
            function mergeBuffers(channelBuffer, rLength) {
                var result = new Float64Array(rLength); // 創建結果陣列
                var offset = 0;                         // 偏移量指針
                var lng = channelBuffer.length;         // 緩衝區數量

                // 逐個複製緩衝區數據到結果陣列
                for (var i = 0; i < lng; i++) {
                    var buffer = channelBuffer[i];      // 當前緩衝區
                    result.set(buffer, offset);         // 複製數據到指定位置
                    offset += buffer.length;            // 更新偏移量
                }

                return result; // 返回合併後的數據
            }

            /**
             * 交錯左右聲道數據
             * 將分離的左右聲道數據交錯排列為立體聲格式
             * @param {Array} leftChannel - 左聲道數據
             * @param {Array} rightChannel - 右聲道數據
             * @returns {Float64Array} 交錯後的立體聲數據
             */
            function interleave(leftChannel, rightChannel) {
                var length = leftChannel.length + rightChannel.length; // 總數據長度
                var result = new Float64Array(length);                  // 結果陣列
                var inputIndex = 0;                                     // 輸入索引

                // 交錯排列左右聲道數據：L R L R L R...
                for (var index = 0; index < length;) {
                    result[index++] = leftChannel[inputIndex];  // 左聲道
                    result[index++] = rightChannel[inputIndex]; // 右聲道
                    inputIndex++;                               // 移至下一組數據
                }
                return result; // 返回交錯後的數據
            }

            /**
             * 將字串寫入 DataView
             * 用於在 WAV 檔案中寫入 UTF-8 字串（如 "RIFF", "WAVE" 等標識符）
             * @param {DataView} view - DataView 物件
             * @param {number} offset - 寫入偏移量
             * @param {string} string - 要寫入的字串
             */
            function writeUTFBytes(view, offset, string) {
                var lng = string.length; // 字串長度
                // 逐字元寫入字串的 UTF-8 編碼
                for (var i = 0; i < lng; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i)); // 寫入字元的 ASCII 碼
                }
            }

            // interleave both channels together
            var interleaved;

            if (numberOfAudioChannels === 2) {
                interleaved = interleave(leftBuffers, rightBuffers);
            }

            if (numberOfAudioChannels === 1) {
                interleaved = leftBuffers;
            }

            var interleavedLength = interleaved.length;

            // create wav file
            var resultingBufferLength = 44 + interleavedLength * 2;

            var buffer = new ArrayBuffer(resultingBufferLength);

            var view = new DataView(buffer);

            // RIFF chunk descriptor/identifier 
            writeUTFBytes(view, 0, 'RIFF');

            // RIFF chunk length
            view.setUint32(4, 44 + interleavedLength * 2, true);

            // RIFF type 
            writeUTFBytes(view, 8, 'WAVE');

            // format chunk identifier 
            // FMT sub-chunk
            writeUTFBytes(view, 12, 'fmt ');

            // format chunk length 
            view.setUint32(16, 16, true);

            // sample format (raw)
            view.setUint16(20, 1, true);

            // stereo (2 channels)
            view.setUint16(22, numberOfAudioChannels, true);

            // sample rate 
            view.setUint32(24, sampleRate, true);

            // byte rate (sample rate * block align)
            view.setUint32(28, sampleRate * 2, true);

            // block align (channel count * bytes per sample) 
            view.setUint16(32, numberOfAudioChannels * 2, true);

            // bits per sample 
            view.setUint16(34, 16, true);

            // data sub-chunk
            // data chunk identifier 
            writeUTFBytes(view, 36, 'data');

            // data chunk length 
            view.setUint32(40, interleavedLength * 2, true);

            // write the PCM samples
            var lng = interleavedLength;
            var index = 44;
            var volume = 1;
            for (var i = 0; i < lng; i++) {
                view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);
                index += 2;
            }

            if (cb) {
                return cb({
                    buffer: buffer,
                    view: view
                });
            }

            postMessage({
                buffer: buffer,
                view: view
            });
        }

        /*---------------------------------------------------------------
         * 瀏覽器兼容性處理
         * 不同瀏覽器使用不同的音頻處理方式
         *--------------------------------------------------------------*/
        if (!isChrome) {
            // Microsoft Edge 瀏覽器：直接在主線程處理
            mergeAudioBuffers(config, function(data) {
                callback(data.buffer, data.view); // 返回處理結果
            });
            return;
        }

        /*---------------------------------------------------------------
         * Chrome 瀏覽器：使用 Web Worker 處理
         * 在背景線程中處理音頻以避免阻塞 UI
         *--------------------------------------------------------------*/
        var webWorker = processInWebWorker(mergeAudioBuffers); // 創建 Web Worker

        // 監聽 Worker 處理完成事件
        webWorker.onmessage = function(event) {
            callback(event.data.buffer, event.data.view); // 返回處理結果
            URL.revokeObjectURL(webWorker.workerURL);      // 釋放記憶體
        };

        webWorker.postMessage(config); // 發送配置數據給 Worker
    }

    /**
     * 在 Web Worker 中處理函數
     * 創建一個 Web Worker 來在背景線程執行指定函數
     * @param {Function} _function - 要在 Worker 中執行的函數
     * @returns {Worker} Web Worker 實例
     */
    function processInWebWorker(_function) {
        // 創建包含函數代碼的 Blob URL
        var workerURL = URL.createObjectURL(new Blob([
            _function.toString(),  // 函數的字串表示
            ';this.onmessage = function (eee) {' + _function.name + '(eee.data);}'  // Worker 訊息處理器
        ], {
            type: 'application/javascript'  // MIME 類型
        }));

        var worker = new Worker(workerURL);  // 創建 Worker
        worker.workerURL = workerURL;        // 保存 URL 引用以便後續清理
        return worker;                       // 返回 Worker 實例
    }
</script>

<!-- 頁腳區域 -->
<footer style="margin-top: 20px;">
    <small id="send-message"></small>
</footer>

<!-- 引入共用腳本（webrtc-experiment.com 的通用函數） -->
<script src="https://www.webrtc-experiment.com/common.js"></script>
</body>
</html>